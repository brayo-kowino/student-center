
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,  initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <title>S.C Space</title>
  <script type="module">    
// Import Firebase libraries
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-app.js";
import { getFirestore, updateDoc, setDoc, getDoc, doc, collection, addDoc, onSnapshot, query, orderBy, serverTimestamp, deleteField} from "https://www.gstatic.com/firebasejs/10.13.2/firebase-firestore.js";
import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, onAuthStateChanged, updateProfile } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-auth.js";
import { getStorage, ref, uploadBytes, getDownloadURL, deleteObject } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-storage.js";



// Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyC8aA9o_8IK4a5-klFszrJbfxwiIR1W9no",
  authDomain: "my-website-d875f.firebaseapp.com",
  projectId: "my-website-d875f",
  storageBucket: "my-website-d875f.appspot.com",
  messagingSenderId: "1084724880551",
  appId: "1:1084724880551:web:5d6a22cf1a1feb26602782",
  measurementId: "G-54E0SH3VJQ"
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const db = getFirestore(app); // Firestore database
const auth = getAuth(app); // Firebase Auth
const storage = getStorage(app); // Firebase Storage

let currentUser = null;
let currentChatUser = null;
let selectedImage = null;
let userPictures = {};

// Function to display messages to users
const displayMessage = (message, isError = false) => {
  const messageElement = document.createElement('div');
  messageElement.textContent = message;
  console.log("display message triggered with message:", message);
  messageElement.className = isError ? 'error-message' : 'success-message';
  
  // Log the created element to check its properties
  console.log("Message Element:", messageElement);

  document.body.appendChild(messageElement);

  // Remove message after a short delay
  setTimeout(() => {
    messageElement.remove();
    console.log("Message removed from DOM");
  }, 3000);
};
 document.getElementById('overlay').style.display = 'none';
 const formatLastSeen = (timestamp) => {
  if (timestamp && timestamp.seconds) {
    const date = new Date(timestamp.seconds * 1000);
    const now = new Date();

    // Create date objects without time components for comparison
    const dateOnly = new Date(date.getFullYear(), date.getMonth(), date.getDate());
    const nowOnly = new Date(now.getFullYear(), now.getMonth(), now.getDate());

    // Check the difference in days
    const timeDiffInDays = (nowOnly - dateOnly) / (1000 * 60 * 60 * 24); // Convert milliseconds to days

    if (timeDiffInDays < 1) {
      return `Last seen today at ${date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hourCycle: 'h23' })}`;
    } else if (timeDiffInDays < 2) {
      return `Last seen yesterday at ${date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hourCycle: 'h23' })}`;
    } else {
      return `Last seen on ${date.toLocaleDateString()} at ${date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hourCycle: 'h23' })}`;
    }
  }
  return ''; // Return empty if no timestamp
};
 // Load users and display their last seen time
const loadUsers = () => {
  const usersRef = collection(db, "users");
  onSnapshot(usersRef, (snapshot) => {
    const userList = document.getElementById('overflow-menu');
    userList.innerHTML = `
      <h3 class="menu-title">S.C Space users</h3>
    `;
    snapshot.forEach(doc => {
      const user = doc.data();
      if (user.uid !== currentUser.uid) {
        userPictures[user.uid] = user.profilePicture ? user.profilePicture : 'pic4.png'; // Store profile pic or default in map

        // Format lastSeen using the conversion function
        const lastSeen = user.lastSeen ? formatLastSeen(user.lastSeen) : ''; 
        const status = user.status === 'online' ? 'Online' : lastSeen ? lastSeen : 'Offline';

        const menuItem = document.createElement('div');
        menuItem.classList.add('menu-item');
        menuItem.innerHTML = `
  <img src="${userPictures[user.uid]}" alt="Profile Pic" class="profile-pic-small">
  <span>${user.name}</span><br>
<span style="color: grey;">${status}</span>
`;
        
       menuItem.setAttribute('data-uid', user.uid);
        menuItem.addEventListener('click', () => {
          currentChatUser = user.uid;
          updateSelectedUser(user.name, status, userPictures[user.uid], user.email, user.bio);
          loadMessages(currentChatUser);
          userList.style.display = 'none'; // Hide menu after selection
        });
        userList.appendChild(menuItem);
      }
    });
  });
};
document.addEventListener('DOMContentLoaded', () => {
  // Get user info from localStorage
  const userInfo = JSON.parse(localStorage.getItem('currentUser'));
  
  if (userInfo) {
    currentUser = userInfo; // Assign currentUser with the stored information
    console.log("Current user:", currentUser);
    
    // Proceed to load user-specific data
    loadUsers();
  } else {
    // Redirect to authentication page if no user is logged in
    window.location.href = "authentication.html"; 
  }
});


// Function to update Firestore with typing status
const setTypingStatus = (userId, isTyping) => {
  const userRef = doc(db, "users", userId);

  console.log(`Attempting to update typing status to ${isTyping} for user ${userId}`);

  updateDoc(userRef, {
    typing: isTyping
  }).then(() => {
    console.log(`Typing status successfully updated to ${isTyping} for user ${userId}`);
  }).catch((error) => {
    console.error("Error updating typing status:", error);
  });
};

// Start typing detection (called after user is authenticated)
const startTypingDetection = (userId) => {
  const messageInput = document.getElementById('message-input');
  console.log("Starting typing detection...");

  if (!messageInput) {
    console.error("Message input field not found!");
    return;
  }

  console.log("Setting up keypress listener on message input.");

  let typingTimer;
  const typingInterval = 3000; // 3 seconds

  // Event listener for keypress in the message input field
  messageInput.addEventListener('keypress', () => {
    console.log("User is typing...");

    // Clear the timer if the user is still typing
    clearTimeout(typingTimer);

    // Set typing to true in Firestore
    setTypingStatus(userId, true);

    // Set a timer to turn off typing status after 3 seconds of inactivity
    typingTimer = setTimeout(() => {
      console.log("User stopped typing after inactivity.");
      setTypingStatus(userId, false);
    }, typingInterval);
  });

  // Alternatively, use 'input' event if 'keypress' doesn't work
  messageInput.addEventListener('input', () => {
    console.log("User is typing (input event)...");

    clearTimeout(typingTimer);
    setTypingStatus(userId, true);

    typingTimer = setTimeout(() => {
      console.log("User stopped typing after inactivity (input event).");
      setTypingStatus(userId, false);
    }, typingInterval);
  });
};
const userInfo = JSON.parse(localStorage.getItem('currentUser'));
if (userInfo && userInfo.uid) {
    currentUser = userInfo; // Assign currentUser with the stored information
    console.log("Current user:", currentUser);

    // Start typing detection
    startTypingDetection(currentUser.uid);
    loadUsers();
} else {
    console.log("No valid user info found in localStorage. Redirecting to authentication page.");
   // window.location.href = "authentication_section.html"; 
}

// Function to update user's status in text view (with last seen and typing)
const updateUserStatusInTextView = (userId) => {
  const userRef = doc(db, "users", userId);

  onSnapshot(userRef, (doc) => {
    if (doc.exists()) {
      const user = doc.data();
      const lastSeen = user.lastSeen ? formatLastSeen(user.lastSeen) : '';
      let status = user.status === 'online' ? 'Online' : lastSeen ? lastSeen : 'Offline';

      if (user.typing) {
        status = 'Typing...';
      }

      document.getElementById('user-status').textContent = status;
    } else {
      console.log("User document not found!");
    }
  });
};

let idleTimeout = null;
let debounceTimeout = null;


// Function to debounce the status updates
const debounceStatusUpdate = (fn, delay = 2000) => {
  clearTimeout(debounceTimeout);
  debounceTimeout = setTimeout(fn, delay);
};

// Function to handle user idle status
const setIdleTimeout = () => {
  clearTimeout(idleTimeout);
  idleTimeout = setTimeout(async () => {
    await setUserOffline();
  }, 5 * 60 * 1000); // Set user offline after 5 minutes of inactivity
};

// Function to set user status to online with debounce
const setUserOnlineDebounced = async () => {
  debounceStatusUpdate(setUserOnline);
};

// Update status on network change
window.addEventListener('online', async () => {
  await setUserOnlineDebounced();
});

window.addEventListener('offline', async () => {
  await setUserOffline();
});

// Listen for user activity to reset idle timer
document.addEventListener('mousemove', setIdleTimeout);
document.addEventListener('keydown', setIdleTimeout);

// Initialize idle timeout when the page loads
setIdleTimeout();

// Keep original code untouched

const updateOnlineStatus = async (uid) => {
  const userRef = doc(db, "users", uid);
  await setDoc(userRef, { status: "online", lastSeen: null }, { merge: true });
};
    // Update user online status
  updateOnlineStatus(currentUser.uid);

// Function to set user status to offline
const setUserOffline = async () => {
  if (currentUser) {
    const userRef = doc(db, "users", currentUser.uid);
    await setDoc(userRef, { status: "offline", lastSeen: new Date() }, { merge: true });
  }
};

// Set online status when the user is active
const setUserOnline = async () => {
  if (currentUser) {
    const userRef = doc(db, "users", currentUser.uid);
    await setDoc(userRef, { status: "online", lastSeen: null }, { merge: true });
    }
};



// Listen for visibility changes
document.addEventListener('visibilitychange', async () => {
  if (document.hidden) {
    await setUserOffline();
  } else {
    await setUserOnlineDebounced();
  }
});

// Listen for beforeunload event
window.addEventListener('beforeunload', async () => {
  await setUserOffline();
});

// Update selected user's UI
// Update selected user's UI and display their profile in a dialog
const updateSelectedUser = (name, status, profilePicture, email, bio) => {
  
  // Update the selected user's UI
  document.getElementById('selected-user').textContent = name;
  document.getElementById('user-status').textContent = status;
  document.getElementById('profile-pic').src = profilePicture ? profilePicture : 'pic4.png';

  // Update the profile dialog with the selected user's details
  document.getElementById('profile-name').textContent = name;
  document.querySelector('.dialog-title').textContent = name;
  document.getElementById('profile-email').textContent = email || "user@example.com"; // Default email
  document.getElementById('profile-bio').textContent = bio || "No Bio Available"; // Default bio
  document.getElementById('profile-picture').src = profilePicture ? profilePicture : 'pic4.png'; // Profile picture

  // Add event listener to the profile picture to show user details
  document.getElementById('profile-pic').onclick = () => {
    // When the profile picture is clicked, show the dialog again
    showUserDetails(name, status, profilePicture, email, bio);
  }
};

// Function to close the dialog
const closeDialog = () => {
  document.getElementById('profile-dialog').style.display = 'none';
  // Re-enable the edit button when the dialog is closed
  const editButton = document.getElementById('edit-button');
  editButton.disabled = false;
};

let userProfilePictureClickListener; // To store the click event listener for user details

// Show the profile dialog with user details
const showUserDetails = (name, status, profilePicture, email, bio) => {
  document.getElementById('overlay').style.display = 'block';
  
  // Disable the edit button
  const editButton = document.getElementById('edit-button');
  editButton.disabled = true;

  // Update user details
  document.getElementById('profile-name').textContent = name;
  document.querySelector('.dialog-title').textContent = name;
  document.querySelector('.dialog-status').textContent = status;
  document.getElementById('profile-email').textContent = email || "user@example.com"; // Default email
  document.getElementById('profile-bio').textContent = bio || "No Bio Available"; // Default bio
  const profilePictureElement = document.getElementById('profile-picture');
  profilePictureElement.src = profilePicture ? profilePicture : 'pic4.png'; // Profile picture

  // Create the click event listener function for the profile picture
  userProfilePictureClickListener = () => {
    showFullScreenImage(profilePictureElement.src);
  };

  // Add click event to show full-screen image
  profilePictureElement.addEventListener('click', userProfilePictureClickListener);

  // Show the dialog
  document.getElementById('profile-dialog').style.display = 'flex';
};

// Close Profile Dialog
const closeProfilesDialog = () => {
  document.getElementById('profile-dialog').style.display = 'none';
  document.getElementById('overlay').style.display = 'none';

  // Remove the click event listener from the profile picture
  const profilePictureElement = document.getElementById('profile-picture');
  if (userProfilePictureClickListener) {
    profilePictureElement.removeEventListener('click', userProfilePictureClickListener);
  }
};

// Event Listeners for Buttons
document.getElementById('close-button').addEventListener('click', closeProfilesDialog);
document.getElementById('edit-button').addEventListener('click', () => {
  showProfileUpdateDialog(currentUser);
  closeProfileDialog(); // Close the profile dialog when editing
});


// Call this function when you want to hide the dialog
const hideDialog = () => {
  closeDialog();
  // Optionally, you can remove the click event listener if needed
  window.onclick = null;
};

  onAuthStateChanged(auth, (user) => {
  if (user) {
    currentUser = user;
   
   displayMessage("Login successful! Welcome back.");
    
    document.getElementById('overlay').style.display = 'none';
    loadUsers();
    updateOnlineStatus(currentUser.uid);
    
  } else {
    document.getElementById('auth-section').style.display = 'block';
    document.getElementById('overlay').style.display = 'block';
    if (currentUser) {
      updateLastSeen(currentUser); // Update last seen if user signs out
    }
    currentUser = null;
  }
});

// Load messages and use the correct profile picture for each sender
const loadMessages = (chatUserId) => {
    updateUserStatusInTextView(currentChatUser);
    startTypingDetection(currentUser.uid);
    
    const chatId = getChatId(currentUser.uid, chatUserId);
    const messagesRef = query(collection(db, "chats", chatId, "messages"), orderBy("timestamp"));
    
    onSnapshot(messagesRef, (snapshot) => {
        const chatBox = document.getElementById('chat-box');
        chatBox.innerHTML = "";

        chatBox.innerHTML += `
            <div class="encryption-message">
                Messages sent by Student Center are end-to-end encrypted. Nobody outside this chat, not even Student Center, can access them.
            </div>
        `;

        snapshot.forEach(doc => {
            const message = doc.data();
            const messageClass = message.senderId === currentUser.uid ? 'sent' : 'received';
            let time, messageText;

            // Check if the message is deleted
            if (message.isDeleted) {
                messageText = message.deletedBy === currentUser.uid 
                    ? "<i>ðŸš« You deleted this message</i>"
                    : "<i>ðŸš« This message was deleted by the sender</i>";
                time = formattTime(message.deletedAt); // Use deleted timestamp
            } else {
                messageText = message.text || ""; // Ensure text is defined
                time = formattTime(message.timestamp); // Use original timestamp
            }

            const image = message.image ? `<img src="${message.image}" alt="Image" style="max-width: 100%; height: auto;" class="message-image" />` : '';
            const audio = message.audio ? `<audio controls class="message-audio"><source src="${message.audio}" type="audio/wav">Your browser does not support the audio element.</audio>` : '';
            console.log('Audio URL:', message.audio); // Check the URL

            const profilePic = message.senderId !== currentUser.uid ? 
                `<img src="${userPictures[message.senderId] || 'pic4.png'}" alt="Profile Pic" class="profile-pic" />` : '';

            // Hide status for deleted messages
            const status = message.isDeleted ? '' : message.senderId === currentUser.uid ? `<span class="status">${message.status}</span>` : '';
            const timeStatus = status ? `${time} â€¢ ${status}` : time;

            const messageContainer = document.createElement('div');
            messageContainer.className = `message-container ${messageClass} ${message.image || message.audio ? 'has-media' : ''}`;
            messageContainer.innerHTML = `
                ${profilePic}
                <div class="message ${messageClass}">
                    ${messageText}
                    ${image}
                    ${audio} <!-- Include audio if it exists -->
                    <div class="time-status">${timeStatus}</div>
                </div>
            `;

            // Add click event for image to open in full screen
           
            if (message.image) {
                const imgElement = messageContainer.querySelector('.message-image');
                imgElement.addEventListener('click', () => {
                    openFullScreenImage(message.image);
                });
            }
            messageContainer.classList.add('no-select');

            // Add long click listener
            messageContainer.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                
                // Check if the message is sent by the current user
                if (message.senderId === currentUser.uid && !message.isDeleted) {
                    openBottomSheet(doc.ref, message.text, chatId, message); // Pass chatId here
                }
            });

            chatBox.appendChild(messageContainer);

            if (message.senderId !== currentUser.uid && message.status !== "read" && !message.isDeleted) {
                const messageRef = doc.ref;
                updateDoc(messageRef, { status: "read" });
            }
        });

        chatBox.scrollTop = chatBox.scrollHeight;
    });
};
const downloadImage = (src, fileName) => {
    if (window.Android) {
        window.Android.downloadImage(src, fileName); // Pass both src and fileName to Android
    }
};

// Function to open image in full screen with overlay and download button
const openFullScreenImage = (src) => {
    // Create the overlay
    const overlay = document.createElement('div');
    overlay.style.position = 'fixed';
    overlay.style.top = '0';
    overlay.style.left = '0';
    overlay.style.width = '100vw';
    overlay.style.height = '100vh';
    overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.7)'; // Semi-transparent black
    overlay.style.zIndex = '999'; // Layer it above other elements
    overlay.style.cursor = 'pointer'; // Change cursor to pointer

    // Create the full-screen image
    const fullScreenImage = document.createElement('img');
    fullScreenImage.src = src;
    fullScreenImage.style.position = 'absolute';
    fullScreenImage.style.top = '50%';
    fullScreenImage.style.left = '50%';
    fullScreenImage.style.transform = 'translate(-50%, -50%)'; // Center the image
    fullScreenImage.style.maxWidth = '100%';
    fullScreenImage.style.maxHeight = '100%';
    fullScreenImage.style.objectFit = 'contain';
    fullScreenImage.style.zIndex = '1000'; // Layer it above the overlay

    // Create the download button
    const downloadButton = document.createElement('button');
    downloadButton.textContent = 'Download';
    downloadButton.style.position = 'absolute';
    downloadButton.style.top = '20px'; // Position it at the top
    downloadButton.style.right = '20px'; // Position it on the right
    downloadButton.style.padding = '10px 15px';
    downloadButton.style.fontSize = '16px';
    downloadButton.style.color = '#fff';
    downloadButton.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
    downloadButton.style.border = 'none';
    downloadButton.style.borderRadius = '5px';
    downloadButton.style.cursor = 'pointer';
    downloadButton.style.zIndex = '1001'; // Layer it above the image

    // Add click event to download the image
    downloadButton.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent closing the overlay
        const fileName = `image-${new Date().getTime()}.jpg`; // Dynamic filename
        downloadImage(src, fileName);
    });

    // Add click event to exit full screen
    overlay.addEventListener('click', () => {
        document.body.removeChild(overlay); // Remove the overlay and image from the DOM
    });

    // Append the button, image, and overlay to the body to display them
    overlay.appendChild(fullScreenImage);
    overlay.appendChild(downloadButton);
    document.body.appendChild(overlay);
};

const openBottomSheet = (messageRef, currentText, chatId, message) => {
    const bottomSheet = document.createElement('div');
    bottomSheet.className = 'bottom-sheet';

    // Check if the message has an image or audio
    const hasMedia = message.image || message.audio;

    bottomSheet.innerHTML = `
        <div class="options">
            ${!hasMedia ? `<div class="option" id="edit-message">Edit</div>` : ''}
            <div class="option" id="delete-message">Delete</div>
            <div class="close">Close</div>
        </div>
    `;

    document.body.appendChild(bottomSheet);

    // Handle edit message option
    if (!hasMedia) {
        bottomSheet.querySelector('#edit-message').addEventListener('click', () => {
            editMessage(messageRef.id, currentText, chatId); // Pass chatId here
            closeBottomSheet(bottomSheet);
        });
    }

    // Handle delete message option
    bottomSheet.querySelector('#delete-message').addEventListener('click', () => {
        deleteMessage(messageRef.id, chatId); // Call your delete function
        closeBottomSheet(bottomSheet);
    });

    // Handle close action
    bottomSheet.querySelector('.close').addEventListener('click', () => {
        closeBottomSheet(bottomSheet);
    });
};
// Function to handle message editing
const editMessage = (messageId, currentText, chatId) => {
  const bottomSheet = document.createElement('div');
  bottomSheet.className = 'bottom-sheet';

  bottomSheet.innerHTML = `
    <div class="edit-dialog">
      <input type="text" id="edit-message-input" value="${currentText}" />
       <div class="button-container">
      <button id="confirm-edit">Confirm</button>
      <div class="close">Close</div>
    </div>
  `;

  document.body.appendChild(bottomSheet);

  bottomSheet.querySelector('#confirm-edit').addEventListener('click', () => {
    const updatedText = document.getElementById('edit-message-input').value;
    updateMessage(messageId, updatedText, chatId); // Pass chatId here
    closeBottomSheet(bottomSheet);
  });

  bottomSheet.querySelector('.close').addEventListener('click', () => {
    closeBottomSheet(bottomSheet);
  });
};
const deleteMessage = (messageId, chatId) => {
  const messageRef = doc(db, "chats", chatId, "messages", messageId);
  
  // Get the message document to check for an image or audio
  getDoc(messageRef).then(docSnapshot => {
    if (docSnapshot.exists()) {
      const message = docSnapshot.data();
      
      // Check if the message has an image
      if (message.image) {
        // Remove the image from Firebase Storage
        const storage = getStorage();
        const imageRef = ref(storage, message.image); // Assuming `message.image` is the image path
        
        deleteObject(imageRef)
          .then(() => {
            console.log("Image deleted successfully from storage.");
          })
          .catch(error => {
            console.error("Error deleting image from storage: ", error);
          });
      }

      // Check if the message has audio
      if (message.audio) {
        // Remove the audio from Firebase Storage
        const storage = getStorage();
        const audioRef = ref(storage, message.audio); // Assuming `message.audio` is the audio path
        
        deleteObject(audioRef)
          .then(() => {
            console.log("Audio deleted successfully from storage.");
          })
          .catch(error => {
            console.error("Error deleting audio from storage: ", error);
          });
      }

      // Update the message document
      updateDoc(messageRef, { 
        text: "ðŸš« <i>The message has been deleted</i>",
        isDeleted: true,
        deletedBy: currentUser.uid,
        deletedAt: serverTimestamp(), // Set the timestamp for when the message is deleted
        image: deleteField(), // Remove the image field from the document
        audio: deleteField() // Remove the audio field from the document
      })
      .then(() => {
        console.log("Message updated successfully!");
      })
      .catch(error => {
        console.error("Error updating message: ", error);
      });
      
    } else {
      console.error("Message not found!");
    }
  }).catch(error => {
    console.error("Error fetching message: ", error);
  });
};

// Function to close the bottom sheet
const closeBottomSheet = (bottomSheet) => {
  if (bottomSheet) {
    bottomSheet.remove();
  }
};

// Function to update the message in the database
const updateMessage = (messageId, updatedText, chatId) => {
  const messageRef = doc(db, "chats", chatId, "messages", messageId);
  updateDoc(messageRef, { text: updatedText })
    .then(() => {
      console.log("Message updated successfully!");
    })
    .catch(error => {
      console.error("Error updating message: ", error);
    });
};

// Formatting the time
const formattTime = (timestamp) => {
  if (timestamp && timestamp.seconds) {
    const date = new Date(timestamp.seconds * 1000);
    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hourCycle: 'h23' });
  }
  return ''; // Return empty if no timestamp
};
let profilePictureClickListener; // To store the click event listener

const showProfileDialog = async () => {
  const editButton = document.getElementById('edit-button');
  editButton.disabled = false;
  document.querySelector('.dialog-title').textContent = "Welcome to S.C Space!";

  if (currentUser) {
    try {
      // Fetch user data from Firestore
      const userDoc = await getDoc(doc(db, "users", currentUser.uid));
      
      if (userDoc.exists()) {
        const userData = userDoc.data();
                
        // Update dialog elements with user data
        const profilePictureElement = document.getElementById('profile-picture');
        profilePictureElement.src = userData.profilePicture || 'pic4.png';             
        document.getElementById('profile-name').textContent = userData.name || 'No Name';
        document.getElementById('profile-email').textContent = userData.email;
        document.getElementById('profile-bio').textContent = userData.bio || 'No bio available'; // Add bio
        document.querySelector('.dialog-status').textContent = "You're visible as online";

        // Create the click event listener function
        profilePictureClickListener = () => {
          showFullScreenImage(profilePictureElement.src);
        };

        // Add click event to show full-screen image
        profilePictureElement.addEventListener('click', profilePictureClickListener);

        // Show the dialog
        document.getElementById('profile-dialog').style.display = 'flex';
        document.getElementById('overlay').style.display = 'block';
      } else {
        alert("User document does not exist."); // Alert if user document doesn't exist
      }
    } catch (error) {
      alert("Error fetching user data: " + error.message); // Alert in case of error
    }
  } else {
    alert("No current user is signed in."); // Alert if no user is signed in
  }
};

// Function to show the profile picture in full screen
const showFullScreenImage = (src) => {
  // Create a full-screen overlay
  const overlay = document.createElement('div');
  overlay.style.position = 'fixed';
  overlay.style.top = '0';
  overlay.style.left = '0';
  overlay.style.width = '100%';
  overlay.style.height = '100%';
  overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
  overlay.style.display = 'flex';
  overlay.style.justifyContent = 'center';
  overlay.style.alignItems = 'center';
  overlay.style.zIndex = '2000';

  // Create an image element
  const image = document.createElement('img');
  image.src = src;
  image.style.maxWidth = '90%'; // Limit the max width
  image.style.maxHeight = '90%'; // Limit the max height
  image.style.borderRadius = '8px'; // Optional: add some styling

  // Append the image to the overlay
  overlay.appendChild(image);

  // Close full-screen on click
  overlay.addEventListener('click', () => {
    document.body.removeChild(overlay); // Remove overlay when clicked
  });

  // Append the overlay to the body
  document.body.appendChild(overlay);
};

// Close Profile Dialog
const closeProfileDialog = () => {
  document.getElementById('profile-dialog').style.display = 'none';
  document.getElementById('overlay').style.display = 'none';

  // Remove the click event listener from the profile picture
  const profilePictureElement = document.getElementById('profile-picture');
  if (profilePictureClickListener) {
    profilePictureElement.removeEventListener('click', profilePictureClickListener);
  }
};

// Event Listeners for Buttons
document.getElementById('close-button').addEventListener('click', closeProfileDialog);
document.getElementById('edit-button').addEventListener('click', () => {
  showProfileUpdateDialog(currentUser);
  closeProfileDialog(); // Close the profile dialog when editing
});
  const markAsRead = async (chatId, messageId) => {
  const messageRef = doc(db, "chats", chatId, "messages", messageId);
  
  try {
    await updateDoc(messageRef, {
      status: "read",
      readTimestamp: new Date() // Log when it was read
    });
  } catch (error) {
    console.error("Error updating document: ", error);
  }
};
    // Function to format the timestamp
const formatTime = (timestamp) => {
  const date = timestamp.toDate(); // Convert Firestore Timestamp to JS Date
  return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); // Format as HH:mm
};
  
// Handle image upload and send the message directly
const handleImageUpload = () => {
  const fileInput = document.getElementById("image-input");
  const file = fileInput.files[0];
  
  if (file) {
    const reader = new FileReader();
    
    reader.onloadend = () => {
      const imageDataUrl = reader.result; // Get the image data URL
      const message = "";
      // Call sendMessage directly with the image data URL
      sendMessage(message, imageDataUrl, null); // Send a message with the image

      // Clear the file input for future uploads
      fileInput.value = ''; 
    };
    
    reader.readAsDataURL(file);
  }
};
    // Add event listener for the image input
document.getElementById('image-input').addEventListener('change', handleImageUpload);

// Real-time listener to detect new messages
const listenForMessages = (chatUserId) => {
  const chatId = getChatId(currentUser.uid, chatUserId);
  const messagesRef = collection(db, "chats", chatId, "messages");

  const unsubscribe = onSnapshot(messagesRef, (snapshot) => {
    snapshot.docChanges().forEach(async (change) => {
      if (change.type === "added") {
        const messageData = change.doc.data();

        // Only observe messages sent by the other user that are still marked as "sent"
        if (messageData.senderId !== currentUser.uid && messageData.status === "sent") {
          const messageElement = document.getElementById(`message-${change.doc.id}`);

          // Use Intersection Observer to detect visibility
          if (messageElement) {
            observeMessageVisibility(chatUserId, change.doc.id, messageElement);
          }
        }
      }
    });
  });

  // Stop listening when user leaves chat
  return unsubscribe;
};

// Observer to detect when the message is visible on the screen
const observeMessageVisibility = (chatUserId, messageId, messageElement) => {
  const observer = new IntersectionObserver(
    async (entries) => {
      entries.forEach(async (entry) => {
        if (entry.isIntersecting) {
          // The message is visible, update its status to "read"
          await updateMessageStatus(chatUserId, messageId, "read");
          observer.unobserve(messageElement); // Stop observing after marking as read
        }
      });
    },
    { threshold: 1.0 } // Fully visible message
  );

  observer.observe(messageElement);
};

// Update message status in Firestore
const updateMessageStatus = async (chatUserId, messageId, newStatus) => {
  const chatId = getChatId(currentUser.uid, chatUserId);
  const messageRef = doc(db, "chats", chatId, "messages", messageId);

  try {
    await setDoc(messageRef, { status: newStatus }, { merge: true }); // Update the status
  } catch (error) {
    console.error("Error updating message status: ", error);
  }
};

  const getChatId = (uid1, uid2) => {
      return uid1 < uid2 ? `${uid1}_${uid2}` : `${uid2}_${uid1}`;
    };


  const showProfileUpdateDialog = async (currentUser) => {
    const dialog = document.getElementById('profile-update-dialog');
    dialog.style.display = 'block';
    document.getElementById('overlay').style.display = 'block';

    const form = document.getElementById('update-profile-form');
    const cancelButton = document.querySelector('.button-cancel'); // Select the cancel button using its class

    // Remove any existing event listeners to avoid multiple submissions
    form.removeEventListener('submit', handleFormSubmit);

    // Attach the event listener for form submission
    form.addEventListener('submit', handleFormSubmit);

    // Attach event listener for the cancel button
    cancelButton.addEventListener('click', () => {
        dialog.style.display = 'none'; // Close the dialog
        document.getElementById('overlay').style.display = 'none';
    });

    // Pre-fill the form with current values
    document.getElementById('name-input').value = currentUser.displayName || '';
    
    // Fetch user data from Firestore to get the latest bio
    try {
        const userDoc = await getDoc(doc(db, "users", currentUser.uid));
        if (userDoc.exists()) {
            const userData = userDoc.data();
            document.getElementById('bio-input').value = userData.bio || ''; // Populate bio field with current bio
        } else {
            console.error("User document does not exist.");
            document.getElementById('bio-input').value = ''; // Fallback if user data is not found
        }
    } catch (error) {
        console.error("Error fetching user data:", error);
        document.getElementById('bio-input').value = ''; // Fallback in case of error
    }

    // Log the current user object for debugging
    console.log("Current User:", currentUser);
    console.log("Current Bio:", currentUser.bio); // Log the current bio for debugging

    async function handleFormSubmit(event) {
        event.preventDefault();
        if (!currentUser) {
            return;
        }

        const name = document.getElementById('name-input').value || currentUser.displayName; // Use current name if none provided
        const bioInput = document.getElementById('bio-input').value; // Get the bio input
        const bio = bioInput !== '' ? bioInput : currentUser.bio; // Use current bio if the new input is empty
        const profilePictureFile = document.getElementById('profile-picture-input').files[0];
        let profilePictureURL = currentUser.photoURL; // Use existing photo URL if no new picture is uploaded

        // If a new profile picture is selected, upload it
        if (profilePictureFile) {
            try {
                alert("Uploading file, please wait");
                const storageRef = ref(storage, `profile_pictures/${currentUser.uid}/${profilePictureFile.name}`);
                const snapshot = await uploadBytes(storageRef, profilePictureFile);
                profilePictureURL = await getDownloadURL(snapshot.ref);
            } catch (error) {
                alert("File upload failed. Error details below:");
                alert(`Error code: ${error.code}`);
                alert(`Error message: ${error.message}`);
                alert(`Error stack: ${error.stack}`);
                return;
            }
        }

        try {
            // Update the profile only with new name and profile picture if provided
            await updateProfile(currentUser, {
                displayName: name,
                photoURL: profilePictureURL // Use the existing or new profile picture URL
            });

            // Prepare data for Firestore update, ensuring bio is valid
            const userData = {
                email: currentUser.email,
                uid: currentUser.uid,
                name: name, // Store the updated or existing name
                bio: bio, // Store the updated or existing bio
                profilePicture: profilePictureURL // Store the updated or existing profile picture URL
            };

            // Update Firestore with user data
            await setDoc(doc(db, "users", currentUser.uid), userData);

            alert("Profile updated successfully!");
            dialog.style.display = 'none';
            document.getElementById('overlay').style.display = 'none';
        } catch (error) {
            alert("Failed to update profile. Please try again.");
            console.error("Failed to update profile:", error);
        }
    }
};
const sendTextMessage = () => {
  const messageInput = document.getElementById("message-input");
  const message = messageInput.value;
  sendMessage(message); // Send the text message
  messageInput.value = ""; // Clear the input after sending
};
// Modify the sendMessage function to accept an audio URL
const sendMessage = async (message, image, audioURL) => {
  if (!currentChatUser) {
    alert("Please select a user to chat with.");
    return;
  }

  const chatId = getChatId(currentUser.uid, currentChatUser);
  listenForMessages(currentChatUser);

  // Check if both message and audioURL are null, don't send empty messages
  if (!message && !image && !audioURL) {
    console.warn("No message or audio to send.");
    return; // Exit early if no content to send
  }

  try {
    await addDoc(collection(db, "chats", chatId, "messages"), {
      senderId: currentUser.uid,
      text: message || null, // Send the text message
      image: image || null,
      audio: audioURL || null, // Send the audio URL if available
      timestamp: new Date(),
      status: "sent"
    });

    // Reset media after sending
    selectedImage = null;
    selectedAudio = null; // Reset audio after sending
  } catch (error) {
    console.error("Error adding document: ", error);
  }
};


document.addEventListener("DOMContentLoaded", () => {
  const voiceButton = document.getElementById("voice-button");
  const sendAudioButton = document.getElementById("send-audio-button");
  const cancelAudioButton = document.getElementById("cancel-audio-button");

  voiceButton.addEventListener("click", async () => {
    await startRecording(); // Start recording
    openRecordingDialog(); // Show recording dialog
  });

  
 // Event listener for cancel button
  cancelAudioButton.addEventListener("click", () => {
    cancelRecording(); // Call the cancel recording function
  });
});

let mediaStream;
let mediaRecorder;
let audioChunks = [];
let selectedAudio;
let isRecording = false;
let isRecordingCanceled = false; // New flag to check if recording was canceled

// Start recording function
const startRecording = async () => {
  try {
    isRecordingCanceled = false; // Reset the cancel flag
    mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    mediaRecorder = new MediaRecorder(mediaStream);
    mediaRecorder.start();

    audioChunks = []; // Reset audio chunks at start

    console.log("Recording started...");

    mediaRecorder.ondataavailable = (event) => {
      console.log("Data available event triggered.");
      audioChunks.push(event.data); // Collect audio chunks
    };

    isRecording = true;
  } catch (error) {
    console.error("Error starting recording: ", error);
  }
};
// Stop recording function with a Promise to wait for onstop to finish
const stopRecording = () => {
  return new Promise((resolve) => {
    if (isRecording) {
      console.log("Stopping recording...");
      mediaRecorder.onstop = () => {
        console.log("Recording stopped. Processing audio chunks...");
        if (!isRecordingCanceled && audioChunks.length > 0) { // Only set audio if recording wasn't canceled
          const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
          selectedAudio = new Blob(audioChunks, { type: 'audio/wav' }); // Create a Blob from audio chunks
                    console.log("Audio Blob created:", selectedAudio); // Log the Blob for debugging
          
        } else {
          console.warn("Recording was canceled or no audio chunks available.");
        }
        audioChunks = []; // Clear audio chunks after processing
        resolve(); // Resolve the Promise after recording has stopped
      };
      mediaRecorder.stop(); // Trigger the onstop event
      mediaStream.getTracks().forEach(track => track.stop()); // Stop the stream
      isRecording = false;
    } else {
      resolve(); // If not recording, resolve immediately
    }
  });
};
const sendAudioButton = document.getElementById("send-audio-button");

sendAudioButton.addEventListener("click", async () => {
    if (isRecording) {
        console.log("Stopping recording and preparing to send audio...");
        await stopRecording(); // Wait for recording to stop and process the audio

        if (selectedAudio) {
            
            const audioURL = await uploadAudio(selectedAudio); // Upload the audio and get the URL
        await sendMessage(null, null, audioURL); // Send the URL instead of the Blob
            closeRecordingDialog(); // Close the dialog after sending
        } else {
            console.warn("No audio to send.");
        }
    }
});
  const uploadAudio = async (audioBlob) => {
  const audioRef = ref(storage, `audio/${Date.now()}.wav`); // Create a unique path for the audio file

  try {
    const snapshot = await uploadBytes(audioRef, audioBlob); // Upload the audio blob
    const downloadURL = await getDownloadURL(snapshot.ref); // Get the download URL
    return downloadURL; // Return the download URL
  } catch (error) {
    console.error("Error uploading audio:", error);
    throw error; // Propagate the error
  }
};


// Cancel recording function
const cancelRecording = () => {
  console.log("Recording canceled.");
  isRecordingCanceled = true; // Set flag to indicate cancellation
  stopRecording(); // Stop the recording
  closeRecordingDialog(); // Close the dialog
  selectedAudio = null; // Reset selectedAudio
  audioChunks = []; // Clear any remaining audio chunks
};

// Function to close the recording dialog
const closeRecordingDialog = () => {
  document.getElementById("recording-dialog").style.display = "none";
  selectedAudio = null; // Reset the audio URL
  audioChunks = []; // Clear the audio chunks
};
// Function to open the recording dialog
const openRecordingDialog = () => {
  document.getElementById("recording-status").textContent = "Recording audio, please speak.";
  document.getElementById("recording-dialog").style.display = "flex";
};

    document.addEventListener('DOMContentLoaded', () => {
      document.getElementById('send-button').addEventListener('click', () => {
        const message = document.getElementById('message-input').value;
        if (message.trim() !== "") {
          sendMessage(message);
          document.getElementById('message-input').value = "";
        }
      });
   document.getElementById('my-profile-button').addEventListener('click', showProfileDialog);
     
        document.getElementById('overflow-button').addEventListener('click', () => {
        const menu = document.getElementById('overflow-menu');
        loadUsers(); // Ensure the menu is updated before showing
        menu.style.display = menu.style.display === 'none' || menu.style.display === '' ? 'block' : 'none';
      });
    });
    // Hide overflow menu when clicking outside
    document.addEventListener('click', (event) => {
      const menu = document.getElementById('overflow-menu');
      const button = document.getElementById('overflow-button');
      if (!menu.contains(event.target) && event.target !== button) {
        menu.style.display = 'none';
      }
    });


 </script>
   <style>
        font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f4f4f4;
      height: 100vh;
      display: flex;
      justify-content: center; /* Center horizontally */
      align-items: center; /* Center vertically */
      overflow: hidden; /* Prevent scrolling */
    }

    h1 {
      margin: 0;
      padding: 15px;
      background-color: #007BFF;
      color: white;
      font-size: 24px;
      text-align: start;
      position: relative;
    }

    .container {
      display: flex;
      flex-direction: column;
      height: 85vh;
      overflow: hidden;
    }
    .success-message {
  color: green;
  background-color: #e0ffe0;
  padding: 10px;
  margin: 10px;
  border: 1px solid green;
  position: fixed; /* Positioning to make it noticeable */
  top: 20px; /* Adjust as necessary */
  right: 20px; /* Adjust as necessary */
  z-index: 1000; /* Ensure it appears above other content */
}

.error-message {
  color: red;
  background-color: #ffe0e0;
  padding: 10px;
  margin: 10px;
  border: 1px solid red;
  position: fixed; /* Positioning to make it noticeable */
  top: 20px; /* Adjust as necessary */
  right: 20px; /* Adjust as necessary */
  z-index: 1000; /* Ensure it appears above other content */
}
    .auth-container {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      width: 320px;          
      padding: 20px;
      background-color: #fff;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      border-radius: 8px;
      text-align: center;
      position: fixed; /* Fixed position to center on screen */
      top: 50%; /* Center vertically */
      left: 50%; /* Center horizontally */
      transform: translate(-50%, -50%); /* Move the container to the center */
      z-index: 1000; /* Make sure it's on top of other elements */
    }
    .menu-title {
    color: #007BFF; /* Blue color */
    font-size: 1.5em; /* Adjust font size as needed */
    margin: 0 0 10px; /* Space below the title */
    font-weight: bold; /* Bold text */
    text-align: center; /* Center the title */
    border-bottom: 2px solid #007BFF; /* Underline for emphasis */
    padding-bottom: 5px; /* Space between title and underline */
}

    .auth-container h1 {
      font-size: 24px;
      color: #1877F2;
      border-bottom: 2px solid #007BFF;
      margin-bottom: 20px;
    }

    .auth-container h3 {
      margin-bottom: 10px;
      color: #333;
    }

    .auth-container p {
      margin: 10px 0;
      color: #555;
      font-size: 14px;
    }

    .auth-container input[type="email"],
    .auth-container input[type="password"] {
      width: 100%;
      padding: 10px;
      margin: 10px 0;
      border: 1px solid #ddd;
      border-radius: 5px;
      box-sizing: border-box;
    }

    .auth-container button {
      width: 100%;
      padding: 12px;
      margin: 10px 0;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
    }
    /* Disable text selection */
.no-select {
    -webkit-user-select: none; /* Chrome, Safari, Opera */
    -moz-user-select: none;    /* Firefox */
    -ms-user-select: none;     /* Internet Explorer/Edge */
    user-select: none;         /* Standard syntax */
}
    .bottom-sheet {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  background-color: white;
  box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.2);
   transition: background-color 0.3s;
  flex: 1; 
  z-index: 1000;
  max-height: 50%; /* Adjust as needed */
  overflow-y: auto; /* Allows scrolling if content exceeds height */
  border-top-left-radius: 16px; /* Rounded corners */
  border-top-right-radius: 16px; /* Rounded corners */
  padding: 16px; /* Add padding for content spacing */
  display: flex;
  flex-direction: column;
}

.option {
  padding: 12px; /* Spacing for each option */
  cursor: pointer; /* Pointer cursor for clickable items */
}

.option:hover {
  background-color: #f0f0f0; /* Hover effect */
}

.close {
  margin-top: 16px; /* Space between options and close button */
  text-align: center; /* Center the close button */
  color: #007BFF; /* Link color */
  cursor: pointer;
}

.edit-dialog {
  display: flex;
  flex-direction: column;
  align-items: center;
}

#edit-message-input {
  width: 90%;
  padding: 10px;
  border: 1px solid #ccc;
  border-radius: 8px;
  margin-bottom: 12px;
  font-size: 16px;
}

.button-container {
  display: flex;
  justify-content: space-between;
  width: 90%;
  margin-top: 12px;
}

#confirm-edit {
  background-color: #007BFF; /* Green */
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 16px;
  transition: background-color 0.3s;
  flex: 1; /* Allows button to grow */
  margin-right: 8px; /* Space between buttons */
}

.close {
  color: #888;
  cursor: pointer;
  text-decoration: underline;
  flex: 1; /* Allows close to grow */
  text-align: center; /* Center the text */
}

.close:hover {
  color: #333;
}

.close:hover {
  color: #333;
}

@keyframes slide-up {
  from {
    transform: translateY(100%);
  }
  to {
    transform: translateY(0);
  }
}

/* Default time status styling */
.time-status {
  font-size: 11px;
  text-align: right;
}

/* Time color for sent messages */
.sent .time-status {
  color: #E0FFFF; /* White for better contrast on blue background */
}

/* Time color for received messages */
.received .time-status {
  color: #555555; /* Darker gray for better contrast on light blue background */
}
.status {
  font-style: italic;
  color: #E0FFFF;
}   
  #register-button {
      background-color: #42b72a;
      color: #fff;
    }

    #sign-in-button {
      background-color: #1877F2;
      color: #fff;
    }

    #privacy-policy-link {
      color: #1877F2;
      text-decoration: none;
    }

    #privacy-policy-link:hover {
      text-decoration: underline;
    }

   #user-info {
  display: flex; /* Align items horizontally */
  align-items: center; /* Center vertically */
  margin: 8px 0; /* Adjust spacing */
  padding: 10px 15px; /* Add padding for spacing */
  background-color: #ffffff; /* Background color */
  border-radius: 8px; /* Rounded corners */
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); /* Shadow all around */
  transition: box-shadow 0.3s ease; /* Smooth transition effect */
}

/* Optional: Add a hover effect for a modern look */
#user-info:hover {
  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15); /* Slightly larger shadow on hover */
}

/* Optional: Add a hover effect for a modern look */
#user-info:hover {
  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15); /* Slightly larger shadow on hover */
}
    #profile-pic {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      margin-left: -5px;
      margin-right: 10px;
    }
  .profile-pic-small {
  width: 70px; /* Set width */
  height: 70px; /* Set height */
  border-radius: 50%; /* Makes the image round */
  object-fit: cover; /* Ensures the image covers the area without distortion */
}

    #selected-user {
      font-size: 16px;
      margin: 10px 0;
      font-weight: bold;
    }

    #user-status {
      font-size: 13px;
      color: gray;
    }

  .encryption-message {
  text-align: center;
  padding: 10px;
  font-size: 12px;
  color: #777;
  background-color: #f1f1f1;
  border-bottom: 1px solid #ddd;
  border-radius: 10px;
  margin-bottom: 10px;
}

/* Container for all messages */
.message-container {
  display: flex;
  align-items: flex-start;
  margin-bottom: 5px; /* Adds space between messages */
}

/* Profile picture styles */
.profile-pic {
  width: 25px;
  height: 25px;
  border-radius: 50%;
  margin-right: 5px;
  margin-left: -5px;
  align-self: flex-start;
}
/* Styles for the profile dialog */
#profile-dialog {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: #ffffff;
    border: 1px solid #ccc;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    z-index: 1000; /* Ensure the dialog is on top */
    width: 350px; /* Set a fixed width for consistency */
    display: none; /* Initially hidden */
    flex-direction: column; /* Stack children vertically */
    align-items: center; /* Center items horizontally */
}

/* Styles for dialog content */
.dialog-content {
    padding: 20px;
    text-align: center; /* Center text */
    width: 100%; /* Ensure the content takes full width of the dialog */
}

/* Styles for the dialog title */
.dialog-title {
    font-size: 24px; /* Increase font size for prominence */
    margin-bottom: 15px; /* Space below the title */
    color: #333; /* Dark color for better readability */
    border-bottom: 2px solid #ccc; /* Add a bottom border */
    padding-bottom: 8px; /* Add padding to move the title away from the border */
    width: 100%; /* Make the border span the entire width of the container */
    text-align: center; /* Keep the title text centered */
}

/* Profile picture styles */
.profile-pic-large {
    width: 200px; /* Set a fixed width for the profile picture */
    height: 200px; /* Set a fixed height for the profile picture */
    border-radius: 50%; /* Circular profile picture */
    margin-bottom: 15px; /* Space below the image */
}

/* Styles for the profile dialog status */
.dialog-status {
    font-size: 13px; /* Smaller font size */
    font-weight: 400; /* Light font weight */
    color: #ffffff; /* White text color */
    background-color: #25D366; /* WhatsApp-like green background */
    padding: 4px 8px; /* Add some padding around the text */
    border-radius: 12px; /* Rounded corners for a label-like effect */
    margin: 10px auto; /* Add space from the elements above and center the status */
    display: block; /* Keep it compact around the text */
    text-align: center; /* Center the text inside the status */
    width: fit-content; /* Shrinks the width around the content */
}

/* Profile details section */
.profile-details {
    text-align: left;
    width: calc(100% - 40px); /* Ensure the content stays within the container, accounting for padding */
    padding-left: 20px;
    padding-right: 20px; /* Add padding on the right to prevent overflow */
    word-wrap: break-word; /* Allow long words or text to wrap within the container */
}

/* Ensure individual text lines are spaced properly */
.profile-details p {
    margin-bottom: 10px;
    color: #555; 
    overflow-wrap: break-word; /* Handle long text breaking gracefully */
    word-wrap: break-word; /* Ensure long words wrap properly */
}


/* Styles for the buttons container */
.dialog-buttons {
    display: flex; /* Flexbox layout for buttons */
    justify-content: space-around; /* Space buttons evenly */
    width: 100%; /* Ensure the button container takes full width */
}

/* Styles for buttons */
.dialog-button {
    padding: 10px 15px; /* Padding for the button */
    border: none; /* Remove default border */
    border-radius: 5px; /* Rounded corners */
    cursor: pointer; /* Pointer cursor on hover */
    font-size: 16px; /* Increase font size */
    transition: background-color 0.3s; /* Smooth transition for hover effects */
}

/* Edit button styles */
#edit-button {
    background-color: #2196F3; /* Blue color */
    color: white; /* White text */
}

/* Edit button hover effect */
#edit-button:hover {
    background-color: #1976D2; /* Darker blue on hover */
}

/* Close button styles */
#close-button {
    background-color: #f44336; /* Red color */
    color: white; /* White text */
}

/* Close button hover effect */
#close-button:hover {
    background-color: #e53935; /* Darker red on hover */
}
/* Styles for received messages */
.received .message {
    display: inline-block;
    background-color: #CCE7FF; /* Light blue for received messages */
    border: 1px solid #A0C3E8; /* Slightly darker border for contrast */
    padding: 10px; /* Increased padding for better spacing */
    border-radius: 15px; /* More rounded corners */
    max-width: 80%; /* Adjust message width */
    margin-bottom: 6px; /* Space between messages */
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Subtle shadow for depth */
    word-wrap: break-word; /* Ensure long words break within the container */
}

/* Adjust for received messages containing images */
.received .message img {
    max-width: 100%; /* Ensure the image fits within the container */
    height: auto; /* Maintain aspect ratio */
}

/* Reduce size for received messages containing images */
.received .message:has(img) {
    max-width: 50%; /* Reduce width for received messages with images */
}

/* Optional: Hover effect for received messages */
.received .message:hover {
    background-color: #B2D4FF; /* Slightly darker blue on hover */
}

/* Styles for sent messages */
.sent .message {
    display: inline-block;
    background-color: #007BFF; /* Blue background for sent messages */
    color: #ffffff; /* White text color for contrast */
    border: 1px solid #0056b3; /* Slightly darker border for contrast */
    padding: 10px; /* Increased padding for better spacing */
    border-radius: 15px; /* More rounded corners */
    max-width: 80%; /* Adjust message width */
    margin-left: auto; /* Align to the right */
    margin-bottom: 6px; /* Space between messages */
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Subtle shadow for depth */
    word-wrap: break-word; /* Ensure long words break within the container */
}

/* Adjust for sent messages containing images */
.sent .message img {
    max-width: 100%; /* Ensure the image fits within the container */
    height: auto; /* Maintain aspect ratio */
}

/* Reduce size for sent messages containing images */
.sent .message:has(img) {
    max-width: 50%; /* Reduce width for sent messages with images */
}

/* Optional: Hover effect for sent messages */
.sent .message:hover {
    background-color: #0056b3; /* Slightly darker blue on hover */
}
  .chat-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0px;
      background-color: #f1f1f1;
      border-bottom: 1px solid #ddd;
    }

    

    #chat-box {
      flex: 1;
      overflow-y: auto;
      padding: 5px;
      padding-bottom: 45px;
      background-color: #ffffff;
     /* border: 1px solid #ddd;*/
    }

.message-input-container {
    position: fixed;
    
    bottom: 0;
    left: 0;
    right: 0;
    display: flex;
    align-items: center; /* Vertically center items */
    padding: 8px; /* Increased padding for better appearance */
    background-color: #f5f5f5; /* Soft grey background for a modern feel */
   // border-top: 0.5px solid #bbb; /* Darker top border */
    box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.15); /* Enhanced shadow for depth */
    border-radius: 10px 10px 0 0; /* Rounded top corners for a modern look */
    transition: box-shadow 0.3s ease; /* Smooth shadow transition */
}

.message-input-container:hover {
    box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.25); /* Darker shadow on hover for interaction feedback */
}
     
#attachment-button,
#voice-button, #send-button {
    background: none; /* Remove default button styles */
    border: none;
    color: blue;
    cursor: pointer; /* Show pointer cursor on hover */
    font-size: 24px; /* Adjust size of the icons */
    margin: 0 2px; /* Space between buttons */
    display: flex; /* Flex display for better alignment */
    align-items: center; /* Center the icons vertically */
}

#message-input {
    flex: 1; /* Take up remaining space */
    padding: 12px;
    border: 1px solid #ccc; /* Border for the input */
    border-radius: 20px; /* Rounded corners */
    margin: 0 1px; /* Space between input and buttons */
    font-size: 16px; /* Font size for better readability */
}

.material-icons {
    font-size: 24px; /* Set the size of the icons */
    line-height: 1; /* Optional: adjust line height to center the icons */
}
    #overflow-button {
    position: absolute;
    top: 12px;
    right: 60px;
    padding: 7.5px 15px;
    background-color: #FF0000; /* Red background */
    color: white; /* Text color */
    border: none; /* No border */
    border-radius: 20px; /* Rounded corners */
    cursor: pointer; /* Pointer cursor on hover */
    display: flex; /* Use flexbox for alignment */
    align-items: center; /* Center icon and text vertically */
    gap: 8px; /* Space between icon and text */
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); /* Subtle shadow */
    transition: background-color 0.3s, box-shadow 0.3s; /* Smooth transition */
}

#overflow-button:hover {
    background-color: #c00000; /* Darker shade on hover */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); /* Enhanced shadow on hover */
}
   .overflow-menu {
  display: none; /* Initially hidden */
  position: absolute; /* Position it absolutely */
  background-color: white; /* Set background color */
  border: 1px solid #ddd; /* Border color */
  border-radius: 10px; /* Rounded corners */
  box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1); /* Subtle shadow for depth */
  z-index: 100; /* Ensure it's above other elements */
  width: 250px; /* Set a fixed width */
  max-height: 500px; /* Set a maximum height */
  overflow-y: auto; /* Enable vertical scrolling */
  padding: 10px; /* Add some padding for spacing */
}
    .menu-item {
      padding: 10px;
      cursor: pointer;
    }

    .menu-item:hover {
      background-color: #f0f0f0;
    }

   #my-profile-button {
  position: absolute;
  top: 10px; /* Position from the top */
  right: 8px; /* Position from the right */
  padding: 5px; /* Smaller padding */
  background-color: #FF0000; /* Button color */
  color: white; /* Icon color */
  border: none; /* Remove border */
  border-radius: 50%; /* Make the button round */
  cursor: pointer; /* Show pointer cursor on hover */
  width: 40px; /* Set a fixed width */
  height: 40px; /* Set a fixed height */
  display: flex; /* Center icon */
  align-items: center; /* Vertically center icon */
  justify-content: center; /* Horizontally center icon */
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); /* Add shadow */
  transition: background-color 0.3s, box-shadow 0.3s; /* Transition effects */
}

#my-profile-button:hover {
  background-color: #D00000; /* Darker shade on hover */
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Slightly larger shadow on hover */
}
/* Center the dialog on the screen */
#profile-update-dialog {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    padding: 20px;
    border: none; /* Removed border for a cleaner look */
    width: 300px;
    background-color: #ffffff; /* White background for contrast */
    text-align: center;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2); /* Softer shadow */
    border-radius: 10px; /* Rounded corners */
    z-index: 1000; /* Ensure it's above other elements */
}

/* Title styling */
#profile-update-dialog h2 {
    color: #007bff; /* Blue color */
    margin-bottom: 20px;
    border-bottom: 2px solid #ddd;
    font-size: 1.5em; /* Slightly larger title */
}

/* Form styling */
#update-profile-form {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

/* Input fields styling */
#update-profile-form label {
    text-align: left;
    margin-bottom: 5px;
    font-weight: bold;
    color: #333; /* Darker text color for better readability */
}

#update-profile-form input[type="text"],
#update-profile-form input[type="file"] {
    padding: 10px;
    width: 100%;
    box-sizing: border-box;
    border: 1px solid #ddd; /* Lighter border color */
    border-radius: 5px; /* Slightly larger border radius */
    transition: border-color 0.3s; /* Transition for border color on focus */
}

#update-profile-form input[type="text"]:focus,
#update-profile-form input[type="file"]:focus {
    border-color: #007bff; /* Change border color on focus */
    outline: none; /* Remove outline */
}

/* Button styling */
.profile-button {
    padding: 10px 15px;
    border: none;
    cursor: pointer;
    border-radius: 5px; /* Rounded corners */
    font-weight: bold; /* Make button text bold */
    transition: background-color 0.3s; /* Transition for background color */
}

/* Cancel button styling */
.button-cancel {
    background-color: #f44336; /* Red */
    color: white;
}

/* Button hover effect */
.button-cancel:hover {
    background-color: #c62828; /* Darker red on hover */
}

.profile-button-container {
    display: flex;
    justify-content: space-between;
    gap: 10px;
}

/* Flex layout for buttons */
.profile-button-container .profile-button {
    flex: 1;
    background-color: #007bff; /* Primary button color */
    color: white;
}

/* Primary button hover effect */
.profile-button-container .profile-button:hover {
    background-color: #0056b3; /* Darker blue on hover */
}
/* Modal Styles */
.modal {
    display: none; /* Hidden by default */
    position: fixed; /* Stay in place */
    z-index: 1000; /* Sit on top */
    left: 0;
    top: 0;
    width: 100%; /* Full width */
    height: 100%; /* Full height */
    overflow: auto; /* Enable scroll if needed */
    background-color: rgba(0, 0, 0, 0.8); /* Black with opacity */
}

.modal-content {
    margin: auto;
    display: block;
    max-width: 90%; /* Responsive width */
    max-height: 90%; /* Responsive height */
}

.clotse {
    position: absolute;
    top: 15px;
    right: 25px;
    color: white;
    font-size: 35px;
    font-weight: bold;
    cursor: pointer;
}
/* Styles for the recording dialog */
#recording-dialog {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: #ffffff;
    border: 1px solid #ccc;
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    z-index: 1000; /* Ensure the dialog is on top */
}

/* Styles for dialog content */
#recording-dialog .dialog-content {
    padding: 20px;
    text-align: center;
}

/* Styles for buttons */
#recording-dialog button {
    padding: 10px 20px; /* Add padding for better click area */
    margin: 10px; /* Spacing between buttons */
    border: none; /* Remove default border */
    border-radius: 5px; /* Rounded corners */
    cursor: pointer; /* Pointer cursor on hover */
    font-size: 16px; /* Increase font size */
}

/* Send button styles */
#send-audio-button {
    background-color: #4CAF50; /* Green color */
    color: white; /* Text color */
    transition: background-color 0.3s; /* Smooth transition */
}

/* Send button hover effect */
#send-audio-button:hover {
    background-color: #45a049; /* Darker green on hover */
}

/* Cancel button styles */
#cancel-audio-button {
    background-color: #f44336; /* Red color */
    color: white; /* Text color */
    transition: background-color 0.3s; /* Smooth transition */
}

/* Cancel button hover effect */
#cancel-audio-button:hover {
    background-color: #e53935; /* Darker red on hover */
}

/* Recording status styles */
#recording-status {
    margin: 10px 0; /* Spacing above and below */
    font-weight: bold; /* Bold text */
}

/* Overlay styling */
#overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.6); /* Semi-transparent black overlay */
    z-index: 999; /* Below the dialog */
}


    .menu-item:hover { background-color: #f0f0f0; }
    input[type="email"], input[type="password"] { padding: 10px; margin: 5px; width: 100%; }
  </style>
</head>
<body>

<div id="profile-update-dialog" style="display:none;">
  <h2>Please hang on a minute to complete your profile</h2>
  <form id="update-profile-form">
    <label for="name-input">Name:</label>
    <input type="text" id="name-input">

    <label for="profile-picture-input">Profile Picture:</label>
    <input type="file" id="profile-picture-input" accept="image/*">

    <label for="bio-input">Bio:</label>
    <textarea id="bio-input"></textarea>

    <div class="profile-button-container">
      <button type="submit" class="profile-button">Update Profile</button>
      <button type="button" class="profile-button button-cancel">Cancel</button>
    </div> 
  </form>
</div>
  <div id="overlay"></div> <!-- Overlay to prevent clicks outside the form -->
 
  <h1></h1>
    <button id="overflow-button">
  <span class="material-icons" style="font-size: 24px;">group</span>
  Show Users
</button>
  <div id="overflow-menu" class="overflow-menu"></div>

    <div id="user-info">
    <img id="profile-pic" src="pic4.png" alt="Profile Picture">
    <div>
      <div id="selected-user">Select a user</div>
      <div id="user-status">Status: Not Available</div>
    </div>
  </div>

  <!-- Profile Dialog -->
<div id="profile-dialog" class="dialog">
  <div class="dialog-content">
    <h2 class="dialog-title">Welcome to S.C Space!</h2>
    <img id="profile-picture" class="profile-pic-large" src="pic4.png" alt="Profile Picture">
    
    <h3 class="dialog-status">You're seen as active now</h3>
         
    <!-- Wrap the profile details inside a container with left alignment -->
    <div class="profile-details">
      <p><strong>Name:</strong> <span id="profile-name">User Name</span></p>
      <p><strong>Email:</strong> <span id="profile-email">user@example.com</span></p>
      <p><strong>Bio:</strong> <span id="profile-bio">No bio available</span></p>
    </div>
    
    <div class="dialog-buttons">
      <button id="edit-button" class="dialog-button">Edit</button>
      <button id="close-button" class="dialog-button">Close</button>
    </div>
  </div>
</div>
    <button id="my-profile-button">
  <span class="material-icons" style="font-size: 24px;">account_circle</span>
</button>
<!-- Chat Section -->
<div class="container">
  <!-- Chat Section -->
  <div id="chat-box"></div>

<!-- Modal for Image Preview -->
<div id="image-modal" class="modal">
    <span class="clotse" id="modal-close">&times;</span>
    <img class="modal-content" id="modal-image" />
    <div id="caption"></div>
</div>

<div class="message-input-container">
  <!-- Inside the message-input-container div -->
  <input type="file" id="image-input" accept="image/*" style="display: none;" />
  
  <!-- Camera Icon Button for Image Attachment -->
  <button id="attachment-button" onclick="document.getElementById('image-input').click();">
    <span class="material-icons">camera_alt</span>
  </button>
  
  <!-- Voice Button -->
  <button id="voice-button">
    <span class="material-icons">mic</span>
  </button>
  
  <!-- Message Input Field -->
  <input type="text" id="message-input" placeholder="Type a message">
  
  <!-- Send Button -->
  <button id="send-button" class="send-button">
    <span class="material-icons">send</span>
  </button>
</div>
<div id="recording-dialog" class="dialog" style="display: none;">
    <div class="dialog-content">
        <h3>Recording...</h3>
        <p id="recording-status">Recording audio, please speak.</p>
        <button id="send-audio-button">Send</button>
        <button id="cancel-audio-button">Cancel</button>
    </div>
</div>
  <script>
  document.getElementById('overflow-button').addEventListener('click', () => {
        const menu = document.getElementById('overflow-menu');
        loadUsers(); // Ensure the menu is updated before showing
        menu.style.display = menu.style.display === 'none' || menu.style.display === '' ? 'block' : 'none';
      });
    
    

    // Hide overflow menu when clicking outside
    document.addEventListener('click', (event) => {
      const menu = document.getElementById('overflow-menu');
      const button = document.getElementById('overflow-button');
      if (!menu.contains(event.target) && event.target !== button) {
        menu.style.display = 'none';
      }
    });
</script>
</body>
</html>
